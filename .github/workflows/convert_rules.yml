name: Auto Convert Clash Rules to MRS

on:
  push:
    branches:
      - main
  workflow_dispatch: # å…è®¸æ‰‹åŠ¨è§¦å‘
  schedule:
    - cron: '0 0 * * 0' # æ¯å‘¨æ—¥ UTC æ—¶é—´ 00:00 è¿è¡Œ

jobs:
  convert-rules:
    runs-on: ubuntu-latest
    permissions:
      contents: write # æˆäºˆ action ä¿®æ”¹ä»“åº“å†…å®¹çš„æƒé™

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all tags, so we can count previous runs on the same day.

      - name: Install dependencies (jq, curl, wget)
        run: sudo apt-get update && sudo apt-get install -y jq curl wget

      - name: Install Mihomo
        run: |
          # å¢åŠ ç‰ˆæœ¬é€‰æ‹©çš„å¥å£®æ€§ï¼Œä¼˜å…ˆé€‰æ‹© compatible ç‰ˆæœ¬
          MIHOMO_LATEST_URL=$(curl -s "https://api.github.com/repos/MetaCubeX/mihomo/releases/latest" | jq -r '.assets[] | select(.name | contains("linux-amd64-compatible")) | .browser_download_url')
          
          # å¦‚æœæ²¡æœ‰ compatible ç‰ˆæœ¬ï¼Œåˆ™é€‰æ‹©ä¸€ä¸ªé€šç”¨çš„ç‰ˆæœ¬ä½œä¸ºå¤‡ç”¨
          if [ -z "$MIHOMO_LATEST_URL" ]; then
            MIHOMO_LATEST_URL=$(curl -s "https://api.github.com/repos/MetaCubeX/mihomo/releases/latest" | jq -r '[.assets[] | select(.name | contains("linux-amd64") and endswith(".gz"))] | .[0].browser_download_url')
          fi

          echo "Downloading Mihomo from $MIHOMO_LATEST_URL"
          
          # ä¸‹è½½ã€è§£å‹ã€èµ‹äºˆæ‰§è¡Œæƒé™å¹¶ç§»åŠ¨åˆ°ç³»ç»Ÿè·¯å¾„
          wget -qO mihomo.gz "$MIHOMO_LATEST_URL"
          gunzip mihomo.gz
          chmod +x mihomo
          sudo mv mihomo /usr/local/bin/
          
          # éªŒè¯å®‰è£…æˆåŠŸ
          echo "Mihomo version:"
          mihomo -v

      - name: Process and Convert Rules
        id: process_rules
        run: |
          set -e # å¦‚æœä»»ä½•å‘½ä»¤å¤±è´¥ï¼Œåˆ™ç«‹å³é€€å‡º

          # --- å…¨å±€å˜é‡å’Œåˆå§‹åŒ– ---
          # åˆ›å»ºä¸´æ—¶ç›®å½•
          DOWNLOADS_DIR="downloads_tmp"
          mkdir -p "$DOWNLOADS_DIR"

          # åˆ›å»ºç‰ˆæœ¬åŒ–è¾“å‡ºç›®å½•
          DATE_SUFFIX=$(date -u +"%Y-%m-%d")
          RUN_COUNT=$(git tag -l "${DATE_SUFFIX}-*" | wc -l)
          VERSION_TAG="${DATE_SUFFIX}-${RUN_COUNT}"
          VERSIONED_OUTPUT_DIR="versioned_rules/$VERSION_TAG"
          RULES_OUTPUT_DIR="$VERSIONED_OUTPUT_DIR/rules"
          mkdir -p "$RULES_OUTPUT_DIR"
          
          # ä¸´æ—¶æ–‡ä»¶ï¼Œç”¨äºå­˜å‚¨æœ€ç»ˆé…ç½®æ–‡ä»¶çš„å„ä¸ªéƒ¨åˆ†
          PROVIDER_LINES_TMP="provider_lines.tmp"
          RULESET_LINES_TMP="ruleset_lines.tmp"
          > "$PROVIDER_LINES_TMP"
          > "$RULESET_LINES_TMP"

          # --- å‡½æ•°å®šä¹‰ ---

          # å‡½æ•°ï¼šè½¬æ¢è§„åˆ™å¹¶è®°å½•ç»“æœ
          convert_and_commit_rule() {
              local type="$1"              # domain, ipcidr, classical
              local format="$2"            # yaml, text
              local input_file="$3"        # å¸¦æœ‰åŸå§‹æ ¼å¼çš„è¾“å…¥æ–‡ä»¶
              local base_name="$4"         # æ–‡ä»¶åŸºç¡€å (e.g., Inside_domain)
              local output_dir="$5"        # è¾“å‡ºç›®å½• (e.g., versioned_rules/2025-09-23/rules)
              local original_name_with_emoji="$6" # æºæ–‡ä»¶ä¸­çš„åŸå§‹åç§° (e.g., ğŸ¯ å›½å†…æµé‡)

              local provider_name="$base_name"
              local final_raw_file="$output_dir/${base_name}.txt"
              local url_path="main/latest/${base_name}"

              if [[ "$type" == "classical" ]]; then
                  local output_file="$output_dir/${base_name}.list"
                  url_path+=".list"
                  cp "$input_file" "$output_file" #ç›´æ¥å¤åˆ¶
                  echo "  Archived unsupported rules to ${output_file}"
              else
                  local output_file="$output_dir/${base_name}.mrs"
                  url_path+=".mrs"
                  local temp_clean_input="cleaned_for_mrs.tmp"

                  # é¢„å¤„ç†ï¼šç§»é™¤ç±»å‹å‰ç¼€ï¼Œä¸ºmrsè½¬æ¢åšå‡†å¤‡
                  # e.g., from "DOMAIN-SUFFIX,google.com" to "google.com"
                  awk -F, '{print $2}' "$input_file" > "$temp_clean_input"

                  echo "  Converting: Type=${type}, Format=${format}"
                  if mihomo convert-ruleset "$type" "$format" "$temp_clean_input" "$output_file"; then
                      echo "  Successfully converted to ${output_file}"
                  else
                      echo "  Error: Conversion for ${input_file} failed."
                      rm -f "$temp_clean_input"
                      return 1
                  fi
                  rm -f "$temp_clean_input"
              fi

              if [ -s "$output_file" ]; then
                  # å½’æ¡£å¸¦æœ‰åŸå§‹æ ¼å¼çš„æºæ–‡ä»¶
                  cp "$input_file" "$final_raw_file"

                  # ç”Ÿæˆ provider é…ç½®è¡Œ
                  local anchor_name="$type"
                  local full_url="https://raw.githubusercontent.com/${{ github.repository }}/${url_path}"
                  echo "  ${provider_name}: { <<: *${anchor_name}, url: '${full_url}' }" >> "$PROVIDER_LINES_TMP"
                  
                  # ç”Ÿæˆ rule-set é…ç½®è¡Œ
                  echo "- RULE-SET,${provider_name},${original_name_with_emoji}" >> "$RULESET_LINES_TMP"
              fi
          }

          # å‡½æ•°ï¼šæ‹†åˆ† .list/.txt å¹¶è¿›è¡Œè½¬æ¢
          split_and_convert() {
              local input_file="$1"
              local base_name="$2"
              local output_dir="$3"
              local original_name_with_emoji="$4"

              echo "  File is a .txt/.list, attempting to split into domain/ipcidr/other..."
              
              local domain_file="${base_name}_domain.txt"
              local ipcidr_file="${base_name}_ipcidr.txt"
              local other_file="${base_name}_other.list"
              > "$domain_file"
              > "$ipcidr_file"
              > "$other_file"
              
              # ä½¿ç”¨ awk é«˜æ•ˆæ‹†åˆ†æ–‡ä»¶ï¼Œå¹¶ä¿æŒåŸå§‹æ ¼å¼
              awk -F, '
                  function strip(s) {
                      sub(/^[ \t\r\n]+/, "", s);
                      sub(/[ \t\r\n]+$/, "", s);
                      return s;
                  }
                  !/^#/ && !/^[ \t\r\n]*$/ {
                      line = strip($0);
                      type = toupper(strip($1));
                      if (type == "DOMAIN" || type == "DOMAIN-SUFFIX" || type == "DOMAIN-KEYWORD") {
                          print line >> "'"$domain_file"'"
                      } else if (type == "IP-CIDR") {
                          print line >> "'"$ipcidr_file"'"
                      } else {
                          print line >> "'"$other_file"'"
                      }
                  }
              ' "$input_file"

              # è½¬æ¢æ‹†åˆ†åçš„æ–‡ä»¶
              if [ -s "$domain_file" ]; then
                  convert_and_commit_rule "domain" "text" "$domain_file" "${base_name}_domain" "$output_dir" "${original_name_with_emoji} (Domain)"
              fi
              if [ -s "$ipcidr_file" ]; then
                  convert_and_commit_rule "ipcidr" "text" "$ipcidr_file" "${base_name}_ipcidr" "$output_dir" "${original_name_with_emoji} (IP)"
              fi
              if [ -s "$other_file" ]; then
                  convert_and_commit_rule "classical" "text" "$other_file" "${base_name}_other" "$output_dir" "${original_name_with_emoji} (Unsupported)"
              fi
              
              rm -f "$domain_file" "$ipcidr_file" "$other_file"
          }

          # å‡½æ•°ï¼šå¤„ç†å•ä¸ªè§„åˆ™
          process_rule() {
              local original_name="$1"
              local url="$2"
              
              echo "---"
              echo "Processing: Name='${original_name}', URL='${url}'"

              # æ£€æŸ¥ URL æ˜¯å¦æœ‰æ•ˆ
              if ! [[ "$url" =~ ^https?:// ]]; then
                  echo "  Warning: Invalid URL format, skipping."
                  return
              fi

              local sanitized_filename_base=$(basename "$url" | sed 's/\.[^.]*$//' | sed 's/[^a-zA-Z0-9_.-]//g')
              local extension="${url##*.}"
              local downloaded_file="$DOWNLOADS_DIR/${sanitized_filename_base}.${extension}"

              echo "  Downloading to ${downloaded_file}..."
              if ! curl -L --retry 3 --fail -s -o "$downloaded_file" "$url"; then
                  echo "  Warning: Download failed for ${url} after 3 retries, skipping."
                  return
              fi

              if [[ "$extension" == "yaml" ]]; then
                  # å‡è®¾ yaml æ–‡ä»¶æ˜¯çº¯ domain ç±»å‹
                  convert_and_commit_rule "domain" "yaml" "$downloaded_file" "$sanitized_filename_base" "$RULES_OUTPUT_DIR" "$original_name"
              elif [[ "$extension" == "txt" || "$extension" == "list" ]]; then
                  split_and_convert "$downloaded_file" "$sanitized_filename_base" "$RULES_OUTPUT_DIR" "$original_name"
              else
                  echo "  Warning: Unsupported file extension '.${extension}', skipping."
              fi
          }

          # --- ä¸»é€»è¾‘ ---
          if [ -s "rule_sources.txt" ]; then
              echo "Custom 'rule_sources.txt' found, processing it."
              while IFS= read -r url; do
                  url=$(echo "$url" | xargs) # æ¸…ç†ç©ºæ ¼å’Œæ¢è¡Œç¬¦
                  if [ -n "$url" ]; then
                      # ä» URL ä¸­æå–ä¸€ä¸ªåˆé€‚çš„åå­—
                      local name=$(basename "$url" | sed 's/\.[^.]*$//')
                      process_rule "$name" "$url"
                  fi
              done < rule_sources.txt
          else
              echo "'rule_sources.txt' not found or is empty, using default .ini file."
              INI_URL="https://raw.githubusercontent.com/cutethotw/ClashRule/main/GeneralClashRule.ini"
              INI_FILE="$DOWNLOADS_DIR/GeneralClashRule.ini"
              curl -s -o "$INI_FILE" "$INI_URL"

              # è§£æ .ini æ–‡ä»¶, `|| true` é˜²æ­¢åœ¨æ²¡æœ‰åŒ¹é…é¡¹æ—¶è„šæœ¬å›  grep çš„é€€å‡ºç  1 è€Œå¤±è´¥
              grep -E '^\s*ruleset=' "$INI_FILE" || true | while IFS= read -r line; do
                  # ç§»é™¤è¡Œé¦–çš„ 'ruleset=' å’Œå¯èƒ½çš„ 'clash-classic:'
                  line_content=$(echo "$line" | sed -e 's/^\s*ruleset=//' -e 's/clash-classic://')
                  
                  # æ›´å¥å£®çš„æå–é€»è¾‘
                  # URL æ˜¯æœ€åä¸€ä¸ªé€—å·ä¹‹åçš„æ‰€æœ‰å†…å®¹
                  url=$(echo "$line_content" | sed -e 's/.*,//' -e 's/^[ \t]*//' -e 's/[ \t]*$//')
                  # åç§°æ˜¯ç¬¬ä¸€ä¸ªé€—å·ä¹‹å‰çš„æ‰€æœ‰å†…å®¹
                  original_name=$(echo "$line_content" | sed -e 's/,.*//' -e 's/^[ \t]*//' -e 's/[ \t]*$//')

                  # å¢åŠ ä¸€ä¸ªæ£€æŸ¥ï¼Œé˜²æ­¢ä»æ ¼å¼é”™è¯¯çš„è¡Œä¸­æå–å‡ºç©ºURL
                  if [ -z "$url" ]; then
                      echo "  Warning: Could not extract a valid URL from line: '$line'. Skipping."
                      continue
                  fi
                  
                  process_rule "$original_name" "$url"
              done
          fi
          
          echo "--- Processing complete ---"
          
          # --- ç”Ÿæˆæœ€ç»ˆé…ç½®æ–‡ä»¶ ---
          PROVIDER_CONFIG_PATH="$VERSIONED_OUTPUT_DIR/provider_config.yaml"
          echo "Generating final config file at $PROVIDER_CONFIG_PATH"

          {
            echo "---"
            echo "# Generated by GitHub Actions at $(date -u --rfc-3339=seconds)"
            echo "# This file uses YAML anchors for a compact configuration."
            echo ""
            echo "rule-anchor:"
            echo "  ip: &ip { type: http, interval: 86400, behavior: ipcidr }"
            echo "  domain: &domain { type: http, interval: 86400, behavior: domain }"
            echo "  classical: &classical { type: http, interval: 86400, behavior: classical }"
            echo ""
            echo "rule-providers:"
            cat "$PROVIDER_LINES_TMP"
            echo ""
            echo "# You can copy the following lines to your main config 'rules:' section."
            echo "# The policy (e.g., PROXY, DIRECT) should be replaced with your actual policy group name."
            echo "# rules:"
            cat "$RULESET_LINES_TMP"
          } > "$PROVIDER_CONFIG_PATH"

          rm -f "$PROVIDER_LINES_TMP" "$RULESET_LINES_TMP"

          # --- ç”Ÿæˆæ±‡æ€»çš„ MD æ–‡ä»¶ ---
          MRS_RULES_MD="mrs_rules.md"
          echo "# MRS Ruleset Links (Always Latest)" > "$MRS_RULES_MD"
          echo "" >> "$MRS_RULES_MD"
          echo "Generated at: $(date -u --rfc-3339=seconds)" >> "$MRS_RULES_MD"
          echo "" >> "$MRS_RULES_MD"
          echo '```yaml' >> "$MRS_RULES_MD"
          grep -E -- '- RULE-SET' "$PROVIDER_CONFIG_PATH" >> "$MRS_RULES_MD"
          echo '```' >> "$MRS_RULES_MD"

          # --- åˆ›å»º latest ç›®å½•å¹¶å¤åˆ¶æœ€æ–°æ–‡ä»¶ ---
          LATEST_DIR="latest"
          rm -rf "$LATEST_DIR"
          mkdir -p "$LATEST_DIR"
          echo "Copying latest rules to /$LATEST_DIR directory..."
          # æ£€æŸ¥ RULES_OUTPUT_DIR ä¸­æ˜¯å¦æœ‰æ–‡ä»¶ï¼Œé˜²æ­¢å›  glob åŒ¹é…ä¸åˆ°æ–‡ä»¶è€ŒæŠ¥é”™
          if [ -n "$(ls -A $RULES_OUTPUT_DIR)" ]; then
              cp -r "$RULES_OUTPUT_DIR"/* "$LATEST_DIR/"
          else
              echo "No new rule files were generated, skipping copy to latest."
          fi
          cp "$PROVIDER_CONFIG_PATH" "$LATEST_DIR/provider_config.yaml"

          # --- å°†æœ€æ–°çš„ provider_config.yaml å¤åˆ¶åˆ°æ ¹ç›®å½• ---
          echo "Copying latest provider_config.yaml to root directory..."
          cp "$LATEST_DIR/provider_config.yaml" ./provider_config.yaml

          # è®¾ç½® git commit çš„ message
          echo "COMMIT_MSG=feat(rules): Auto update MRS rulesets to version $VERSION_TAG" >> $GITHUB_ENV
          # åˆ›å»ºæ–°çš„ tag
          git tag "$VERSION_TAG"

      - name: Commit and Push to repository
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # æ·»åŠ æ‰€æœ‰æ–°ç”Ÿæˆçš„æ–‡ä»¶
          git add latest/ versioned_rules/ mrs_rules.md provider_config.yaml
          
          # æ£€æŸ¥æ˜¯å¦æœ‰æ–‡ä»¶å˜åŠ¨
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            # ä½¿ç”¨ä¸Šä¸€æ­¥çš„è¾“å‡ºä½œä¸º commit message çš„ä¸€éƒ¨åˆ†
            git commit -m "${{ env.COMMIT_MSG }}"
            git push --follow-tags
          fi

